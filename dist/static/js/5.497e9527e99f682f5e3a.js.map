{"version":3,"sources":["webpack:///static/js/5.497e9527e99f682f5e3a.js","webpack:///./src/components/index/basic/Bind.vue","webpack:///./src/components/index/basic/Bind.vue?dbc2","webpack:///Bind.vue"],"names":["webpackJsonp","174","module","exports","__webpack_require__","Component","219","render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","230","applyDemo","console","log","applyVar","ParentFunc","name","age","printInfo","height","ChildFunc","arguments","call","Function","prototype","bind","context","that","apply","obj","testVar","func","obj1"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,EAASC,GCHjC,GAAAC,GAAAD,EAAA,GAEAA,EAAA,KAEAA,EAAA,KAEA,KAEA,KAEA,KAGAF,GAAAC,QAAAE,EAAAF,SDUMG,IACA,SAAUJ,EAAQC,GExBxBD,EAAAC,SAAgBI,OAAA,WAAmB,GAAAC,GAAAC,KAAaC,EAAAF,EAAAG,cAA0BH,GAAAI,MAAAC,EAC1E,OAAAL,GAAAM,GAAA,IACCC,iBAAA,WAA+B,GAAAP,GAAAC,KAAaC,EAAAF,EAAAG,eAA0BE,EAAAL,EAAAI,MAAAC,IAAAH,CACvE,OAAAG,GAAA,OAAAA,EAAA,MAAAL,EAAAQ,GAAA,cAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,iDAAAR,EAAAQ,GAAA,KAAAH,EAAA,OAAAL,EAAAQ,GAAA,icAAkhBR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,gBAAAR,EAAAQ,GAAA,KAAAH,EAAA,OAAAL,EAAAQ,GAAA,iVAAmaH,EAAA,QAAAL,EAAAQ,GAAA,wBAAAR,EAAAQ,GAAA,WAAqIH,EAAA,QAAAL,EAAAQ,GAAA,oDAAAR,EAAAQ,GAAA,yDAAAH,EAAA,QAAAL,EAAAQ,GAAA,2CAAAR,EAAAQ,GAAA,sBAA2NH,EAAA,QAAAL,EAAAQ,GAAA,4BAA+DR,EAAAQ,GAAA,QAAAR,EAAAQ,GAAA,KAAAH,EAAA,MAAAL,EAAAQ,GAAA,sBAAAR,EAAAQ,GAAA,KAAAH,EAAA,OAAAL,EAAAQ,GAAA,wTAAuWH,EAAA,QAAAL,EAAAQ,GAAA,UAAAR,EAAAQ,GAAA,MAAAH,EAAA,QAAAL,EAAAQ,GAAA,eAAAR,EAAAQ,GAAA,uWF+BrrDC,IACA,SAAUf,EAAQC,GG4DxB,QAAAe,KHsCEC,QAAQC,IAAIX,KGpCdY,UAKA,QAAAC,GAAAC,EAAAC,GHsCEf,KAAKc,KGpCPA,EHqCEd,KAAKe,IGpCPA,EHqCEf,KAAKgB,UAAY,WACfN,QAAQC,IAAI,QAAUX,KAAKc,KAAO,QAAUd,KAAKe,IAAM,WAAaf,KGpCxEiB,SAGA,QAAAC,GAAAJ,EAAAC,GHsCEL,QAAQC,IGpCVQ,WHqCEnB,KAAKiB,OGpCP,MHqCEJ,EAAWO,KAAKpB,KAAMc,EGpCxBC,GAzCAM,SAAAC,UAAAC,KAAAF,SAAAC,UAAAC,MAAA,SAAAC,GHsCE,GAAIC,GGpCNzB,IHqCE,OAAO,YACL,MAAOyB,GAAKC,MAAMF,EGpCtBL,YAEA,IAAAQ,IHsCEC,QGpCF,SAEAC,EAAA,WHsCEnB,QAAQC,IAAIX,KGpCd4B,SACAC,MACAA,IAAAN,KAAAI,KAKA,IAAAG,IHsCElB,SGpCF,UAIAH,KACAA,EAAAiB,MAAAI,GAkBA,GAAAZ,GAAA,WACAF,YAEA,GAAAH,GAAA,WAAAG","file":"static/js/5.497e9527e99f682f5e3a.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ 174:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(230),\n  /* template */\n  __webpack_require__(219),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 219:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h2', [_vm._v(\"bind函数实现\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"以下代码是在vue组件中，通过webpack打包，否则第一个func()结果应为lol\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    /* eslint-disable */\\n    Function.prototype.bind = Function.prototype.bind || function (context) {\\n      const that = this\\n      return function () {\\n        return that.apply(context, arguments)\\n      }\\n    }\\n    const obj = {\\n      testVar: 'lalal'\\n    }\\n    const testVar = 'lol'\\n    let func = function () {\\n      console.log(this.testVar)\\n    }\\n    func() // undefined\\n    func = func.bind(obj)\\n    func() // lalal\\n  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"call&apply\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    // function.apply(obj, array||arguments)\\n    // 代表将function里面的this指针指向obj\\n    // 所以如果在function中运行this.prop,结果将是obj里面的prop属性值，如下：\\n    const obj1 = {\\n      applyVar: 'test123'\\n    }\\n    function applyDemo() {\\n      console.log(this.applyVar)\\n    }\\n    applyDemo() // undefined\\n    applyDemo.apply(obj1) // test123\\n\\n    \"), _c('span', [_vm._v(\"备注：call和apply的用法相同\")]), _vm._v(\";\\n    \"), _c('span', [_vm._v(\"差别在于apply的第二个参数只能是数组或者arguments,call可以传任意类型的参数\")]), _vm._v(\"。\\n    运行以下语句可以将arguments转换为数组，从而可以让apply进行数组传参\\n    \"), _c('span', [_vm._v(\"Array.prototype.slice.call(arguments)\")]), _vm._v(\";\\n    ES6可用\\n    \"), _c('span', [_vm._v(\"Array.from(arguments);\")]), _vm._v(\"  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"利用call&apply实现继承\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    // 利用call/apply来实现继承\\n    function ParentFunc(name, age) {\\n      this.name = name\\n      this.age = age\\n      this.printInfo = function () {\\n        console.log('name=' + this.name + '&age=' + this.age + '&height=' + this.height)\\n      }\\n    }\\n\\n    // 继承ParentFunc里面的所有内容\\n    // 但是此时ParentFunc里面的\"), _c('span', [_vm._v(\"this\")]), _vm._v(\"指向\"), _c('span', [_vm._v(\"ChildFunc\")]), _vm._v(\".\\n    function ChildFunc(name, age) {\\n      this.height = '185'\\n      ParentFunc.call(this, name, age)\\n      // ParentFunc.apply(this, arguments) // 效果一样\\n    }\\n\\n    const child = new ChildFunc('小张', '19')\\n    child.printInfo() // name=小张&age=19&height=185\\n\\n    new ParentFunc('小张', '19').printInfo() //name=小张&age=19&height=undefined\\n  \")])])\n}]}\n\n/***/ }),\n\n/***/ 230:\n/***/ (function(module, exports) {\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* eslint-disable */\nFunction.prototype.bind = Function.prototype.bind || function (context) {\n  var that = this;\n  return function () {\n    return that.apply(context, arguments);\n  };\n};\nvar obj = {\n  testVar: 'lalal'\n};\nvar testVar = 'lol';\nvar func = function func() {\n  console.log(this.testVar);\n};\nfunc(); // undefined\nfunc = func.bind(obj);\nfunc(); // lalal\n\n// function.apply(obj, array||arguments)\n// 代表将function里面的this指针指向obj，所以如果在function中运行this.prop,结果将是obj里面的prop属性值，如下：\nvar obj1 = {\n  applyVar: 'test123'\n};\nfunction applyDemo() {\n  console.log(this.applyVar);\n}\napplyDemo(); // undefined\napplyDemo.apply(obj1); // test123\n\n// 利用call/apply来实现继承\nfunction ParentFunc(name, age) {\n  this.name = name;\n  this.age = age;\n  this.printInfo = function () {\n    console.log('name=' + this.name + '&age=' + this.age + '&height=' + this.height);\n  };\n}\n\nfunction ChildFunc(name, age) {\n  console.log(arguments);\n  this.height = '185';\n  ParentFunc.call(this, name, age);\n  // ParentFunc.apply(this, arguments) // 效果一样\n}\n\nvar child = new ChildFunc('小张', '19');\nchild.printInfo(); // name=小张&age=19&height=185\n\nnew ParentFunc('小张', '19').printInfo(); //name=小张&age=19&height=undefined\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/5.497e9527e99f682f5e3a.js","var Component = require(\"!../../../../node_modules/.12.2.2@vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../node_modules/.12.2.2@vue-loader/lib/selector?type=script&index=0!./Bind.vue\"),\n  /* template */\n  require(\"!!../../../../node_modules/.12.2.2@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-1f0db924\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../../node_modules/.12.2.2@vue-loader/lib/selector?type=template&index=0!./Bind.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/index/basic/Bind.vue\n// module id = 174\n// module chunks = 5","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(0)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h2', [_vm._v(\"bind函数实现\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"以下代码是在vue组件中，通过webpack打包，否则第一个func()结果应为lol\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    /* eslint-disable */\\n    Function.prototype.bind = Function.prototype.bind || function (context) {\\n      const that = this\\n      return function () {\\n        return that.apply(context, arguments)\\n      }\\n    }\\n    const obj = {\\n      testVar: 'lalal'\\n    }\\n    const testVar = 'lol'\\n    let func = function () {\\n      console.log(this.testVar)\\n    }\\n    func() // undefined\\n    func = func.bind(obj)\\n    func() // lalal\\n  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"call&apply\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    // function.apply(obj, array||arguments)\\n    // 代表将function里面的this指针指向obj\\n    // 所以如果在function中运行this.prop,结果将是obj里面的prop属性值，如下：\\n    const obj1 = {\\n      applyVar: 'test123'\\n    }\\n    function applyDemo() {\\n      console.log(this.applyVar)\\n    }\\n    applyDemo() // undefined\\n    applyDemo.apply(obj1) // test123\\n\\n    \"), _c('span', [_vm._v(\"备注：call和apply的用法相同\")]), _vm._v(\";\\n    \"), _c('span', [_vm._v(\"差别在于apply的第二个参数只能是数组或者arguments,call可以传任意类型的参数\")]), _vm._v(\"。\\n    运行以下语句可以将arguments转换为数组，从而可以让apply进行数组传参\\n    \"), _c('span', [_vm._v(\"Array.prototype.slice.call(arguments)\")]), _vm._v(\";\\n    ES6可用\\n    \"), _c('span', [_vm._v(\"Array.from(arguments);\")]), _vm._v(\"  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"利用call&apply实现继承\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"    // 利用call/apply来实现继承\\n    function ParentFunc(name, age) {\\n      this.name = name\\n      this.age = age\\n      this.printInfo = function () {\\n        console.log('name=' + this.name + '&age=' + this.age + '&height=' + this.height)\\n      }\\n    }\\n\\n    // 继承ParentFunc里面的所有内容\\n    // 但是此时ParentFunc里面的\"), _c('span', [_vm._v(\"this\")]), _vm._v(\"指向\"), _c('span', [_vm._v(\"ChildFunc\")]), _vm._v(\".\\n    function ChildFunc(name, age) {\\n      this.height = '185'\\n      ParentFunc.call(this, name, age)\\n      // ParentFunc.apply(this, arguments) // 效果一样\\n    }\\n\\n    const child = new ChildFunc('小张', '19')\\n    child.printInfo() // name=小张&age=19&height=185\\n\\n    new ParentFunc('小张', '19').printInfo() //name=小张&age=19&height=undefined\\n  \")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.12.2.2@vue-loader/lib/template-compiler?{\"id\":\"data-v-1f0db924\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/.12.2.2@vue-loader/lib/selector.js?type=template&index=0!./src/components/index/basic/Bind.vue\n// module id = 219\n// module chunks = 5","<template>\r\n  <div>\r\n    <h2>bind函数实现</h2>\r\n    <h3>以下代码是在vue组件中，通过webpack打包，否则第一个func()结果应为lol</h3>\r\n    <pre>\r\n      /* eslint-disable */\r\n      Function.prototype.bind = Function.prototype.bind || function (context) {\r\n        const that = this\r\n        return function () {\r\n          return that.apply(context, arguments)\r\n        }\r\n      }\r\n      const obj = {\r\n        testVar: 'lalal'\r\n      }\r\n      const testVar = 'lol'\r\n      let func = function () {\r\n        console.log(this.testVar)\r\n      }\r\n      func() // undefined\r\n      func = func.bind(obj)\r\n      func() // lalal\r\n    </pre>\r\n    <h3>call&apply</h3>\r\n    <pre>\r\n      // function.apply(obj, array||arguments)\r\n      // 代表将function里面的this指针指向obj\r\n      // 所以如果在function中运行this.prop,结果将是obj里面的prop属性值，如下：\r\n      const obj1 = {\r\n        applyVar: 'test123'\r\n      }\r\n      function applyDemo() {\r\n        console.log(this.applyVar)\r\n      }\r\n      applyDemo() // undefined\r\n      applyDemo.apply(obj1) // test123\r\n\r\n      <span>备注：call和apply的用法相同</span>;\r\n      <span>差别在于apply的第二个参数只能是数组或者arguments,call可以传任意类型的参数</span>。\r\n      运行以下语句可以将arguments转换为数组，从而可以让apply进行数组传参\r\n      <span>Array.prototype.slice.call(arguments)</span>;\r\n      ES6可用\r\n      <span>Array.from(arguments);</span>\r\n    </pre>\r\n    <h3>利用call&apply实现继承</h3>\r\n    <pre>\r\n      // 利用call/apply来实现继承\r\n      function ParentFunc(name, age) {\r\n        this.name = name\r\n        this.age = age\r\n        this.printInfo = function () {\r\n          console.log('name=' + this.name + '&age=' + this.age + '&height=' + this.height)\r\n        }\r\n      }\r\n\r\n      // 继承ParentFunc里面的所有内容\r\n      // 但是此时ParentFunc里面的<span>this</span>指向<span>ChildFunc</span>.\r\n      function ChildFunc(name, age) {\r\n        this.height = '185'\r\n        ParentFunc.call(this, name, age)\r\n        // ParentFunc.apply(this, arguments) // 效果一样\r\n      }\r\n\r\n      const child = new ChildFunc('小张', '19')\r\n      child.printInfo() // name=小张&age=19&height=185\r\n\r\n      new ParentFunc('小张', '19').printInfo() //name=小张&age=19&height=undefined\r\n    </pre>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n/* eslint-disable */\r\nFunction.prototype.bind = Function.prototype.bind || function (context) {\r\n  const that = this\r\n  return function () {\r\n    return that.apply(context, arguments)\r\n  }\r\n}\r\nconst obj = {\r\n  testVar: 'lalal'\r\n}\r\nconst testVar = 'lol'\r\nlet func = function () {\r\n  console.log(this.testVar)\r\n}\r\nfunc() // undefined\r\nfunc = func.bind(obj)\r\nfunc() // lalal\r\n\r\n// function.apply(obj, array||arguments)\r\n// 代表将function里面的this指针指向obj，所以如果在function中运行this.prop,结果将是obj里面的prop属性值，如下：\r\nconst obj1 = {\r\n  applyVar: 'test123'\r\n}\r\nfunction applyDemo() {\r\n  console.log(this.applyVar)\r\n}\r\napplyDemo() // undefined\r\napplyDemo.apply(obj1) // test123\r\n\r\n// 利用call/apply来实现继承\r\nfunction ParentFunc(name, age) {\r\n  this.name = name\r\n  this.age = age\r\n  this.printInfo = function () {\r\n    console.log('name=' + this.name + '&age=' + this.age + '&height=' + this.height)\r\n  }\r\n}\r\n\r\nfunction ChildFunc(name, age) {\r\n  console.log(arguments)\r\n  this.height = '185'\r\n  ParentFunc.call(this, name, age)\r\n  // ParentFunc.apply(this, arguments) // 效果一样\r\n}\r\n\r\nconst child = new ChildFunc('小张', '19')\r\nchild.printInfo() // name=小张&age=19&height=185\r\n\r\nnew ParentFunc('小张', '19').printInfo() //name=小张&age=19&height=undefined\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Bind.vue?03f3c63a"],"sourceRoot":""}