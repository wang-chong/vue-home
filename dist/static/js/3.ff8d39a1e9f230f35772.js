webpackJsonp([3],{177:function(t,n,r){var e=r(0)(r(232),r(218),null,null,null);t.exports=e.exports},216:function(t,n,r){"use strict";r.d(n,"b",function(){return e}),r.d(n,"a",function(){return s});var e=function(){function t(t){this.next=null,this.prev=null,this.ele=t}this.first=null,this.last=null,this.size=0,this.addFirst=function(n){var r=new t(n);r.next=this.first,this.size>0&&(this.first.prev=r),this.first=r,0===this.size&&(this.last=this.first),this.size++},this.addLast=function(n){var r=new t(n);r.prev=this.last,this.size>0&&(this.last.next=r),this.last=r,0===this.size&&(this.first=this.last),this.size++},this.removeFirst=function(){if(0===this.size)return null;var t=this.first;return this.first=this.first.next,this.first?this.first.prev=null:this.last=null,this.size--,t},this.removeFirstWithoutBack=function(){this.removeFirst();return null},this.removeLast=function(){if(0===this.size)return null;var t=this.last;return this.last=this.last.prev,this.last?this.last.next=null:this.first=null,this.size--,t},this.removeLastWithoutBack=function(){this.removeLast();return null},this.removeIndex=function(t){if(t>=this.size||t<=0)return null;switch(t){case 1:return this.removeFirst();case this.size-1:return this.removeLast();default:for(var n=1,r=this.first;n!==t;)if(n++,r=r.next,n===t)return r.prev.next=r.next,r.next.prev=r.prev,r}},this.removeIndexWithoutBack=function(t){this.removeIndex(t);return null},this.toString=function(){for(var t=this.first,n=[];t;)n.push(t.ele),t=t.next;return n.join(",")}},s=function(){function t(t){this.ele=t,this.lc=null,this.rc=null,this.father=null}this.first=null,this.last=null,this.floor=0,this.add=function(n){var r=new t(n);if(0===this.floor)this.first=r,this.floor++;else if(1===this.floor)this.last.lc=r,r.father=this.last,this.floor++;else for(var e=this.last;e;){if(e.father.lc===e){if(e.father.rc){for(e=e.father.rc;e.lc;)e=e.lc;e.lc=r,r.father=e;break}e.father.rc=r,r.father=e.father;break}if(e.father===this.first){for(e=this.first;e.lc;)e=e.lc;e.lc=r,r.father=e,this.floor++;break}e=e.father}this.last=r},this.removeLast=function(){var t=this.last,n=this.last;if(0===this.floor)return null;if(1===this.floor)return this.first=null,this.last=null,this.floor=0,t;if(n===n.father.lc){for(;n.father;)if(n!==n.father.lc){if(n===n.father.rc){for(n=n.father.lc;n.rc;)n=n.rc;return this.last=n,t.father.lc=null,t}}else n=n.father;for(;n.rc;)n=n.rc;return t.father.lc=null,this.last=n,this.floor--,t}return n===n.father.rc?(n.father.rc=null,this.last=n.father.lc,t):void 0},this.removeLastWithoutBack=function(){this.removeLast();return null},this.toStringDeepFirst=function(){function t(r){var e=r.ele;if(n.push(e),r.lc)return void t(r.lc);for(;r&&r.father;){if(r.father.rc&&r.father.rc!==r)return void t(r.father.rc);r=r.father}}var n=[];return this.first&&t(this.first),n.join(",")},this.toStringBreadthFirst=function(){var t=[],n=this.first;if(!n)return"";var r=new e;for(r.addLast(n);r.size>0;){var s=r.removeFirst().ele;t.push(s.ele),s.lc&&r.addLast(s.lc),s.rc&&r.addLast(s.rc)}return t.join(",")},this.getFloor=function(){return this.floor}}},218:function(t,n){t.exports={render:function(){var t=this,n=t.$createElement;t._self._c;return t._m(1)},staticRenderFns:[function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("pre",[t._v("    // 向二叉树加入一个数据\n    "),r("span",[t._v("add(data)")]),t._v(";\n\n    // 移除最后一个数据(且返回最后一个数据)\n    "),r("span",[t._v("removeLast()")]),t._v(";\n\n    // 移除最后一个数据("),r("span",[t._v("不返回")]),t._v("最后一个数据)\n    "),r("span",[t._v("removeLastWithoutBack()")]),t._v(";\n    \n    // 深度优先遍历二叉树\n    "),r("span",[t._v("toStringDeepFirst()")]),t._v(";\n\n    // 广度优先遍历二叉树\n    "),r("span",[t._v("toStringBreadthFirst()")]),t._v(";\n\n    // 获取二叉树的层数\n    "),r("span",[t._v("getFloor()")]),t._v(";\n  ")])},function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("div",[r("h2",[t._v("js实现标准二叉树存储方式")]),t._v(" "),r("h3",[t._v("构造函数如下")]),t._v(" "),r("pre",[t._v("  function Tree () {\n    this.first = null\n    this.last = null\n    this.floor = 0\n\n    function Node (ele) {\n      this.ele = ele\n      this.lc = null\n      this.rc = null\n      this.father = null\n    }\n\n    // 往二叉树加入一个节点\n    this.add = function (ele) {\n      const node = new Node(ele)\n      if (this.floor === 0) { // 一个元素都没有\n        this.first = node\n        this.floor++\n      } else if (this.floor === 1) { // 只有一个元素\n        this.last.lc = node\n        node.father = this.last\n        this.floor++\n      } else {\n        let current = this.last\n        while (current) {\n          // 当前节点是父节点的左节点\n          if (current.father.lc === current) {\n            if (current.father.rc) {\n              // 父节点有右节点\n              current = current.father.rc\n              while (current.lc) {\n                current = current.lc\n              }\n              current.lc = node\n              node.father = current\n              break\n            } else {\n              // 添加一个兄弟节点\n              current.father.rc = node\n              node.father = current.father\n              break\n            }\n          // 当前节点是父节点的右节点\n          } else {\n            if (current.father === this.first) {\n              current = this.first\n              while (current.lc) {\n                current = current.lc\n              }\n              current.lc = node\n              node.father = current\n              this.floor++\n              break\n            }\n            current = current.father\n          }\n        }\n      }\n      this.last = node\n    }\n\n    // 删除二叉树的最后一个节点, 且返回节点\n    this.removeLast = function () {\n      const last = this.last\n      let current = this.last\n      if (this.floor === 0) {\n        return null\n      }\n      if (this.floor === 1) {\n        this.first = null\n        this.last = null\n        this.floor = 0\n        return last\n      }\n      if (current === current.father.lc) {\n        while (current.father) {\n          // 左节点\n          if (current === current.father.lc) {\n            current = current.father\n            continue\n          }\n          if (current === current.father.rc) {\n            current = current.father.lc\n            while (current.rc) {\n              current = current.rc\n            }\n            this.last = current\n            // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\n            last.father.lc = null\n            return last\n          }\n        }\n        while (current.rc) {\n          current = current.rc\n        }\n        last.father.lc = null\n        this.last = current\n        this.floor--\n        return last\n      }\n      if (current === current.father.rc) {\n        current.father.rc = null\n        this.last = current.father.lc\n        return last\n      }\n    }\n    // 删除二叉树的最后一个节点, 不返回节点\n    this.removeLastWithoutBack = function () {\n      let last = this.removeLast()\n      last = null\n      return last\n    }\n\n    // 深度优先遍历（先序）\n    this.toStringDeepFirst = function () {\n      function next (current) {\n        const ele = current.ele\n        eleArr.push(ele)\n        // 深度优先，所以只要有左节点就继续往下找\n        if (current.lc) {\n          next(current.lc)\n          return\n        }\n        // 没有左节点，需要看是否有父节点，父节点是否有右节点\n        // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\n        // 关键：父节点的右节点不能是当前节点，否则会死循环\n        while (current && current.father) {\n          if (current.father.rc && current.father.rc !== current) {\n            next(current.father.rc)\n            return\n          }\n          current = current.father\n        }\n      }\n\n      // 深度优先另一种实现方式\n      // function next (current) {\n      //   const ele = current.ele\n      //   eleArr.push(ele)\n      //   if (current.lc) {\n      //     next(current.lc)\n      //   }\n      //   if (current.rc) {\n      //     next(current.rc)\n      //   }\n      // }\n      const eleArr = []\n      if (this.first) {\n        next(this.first)\n      }\n      return eleArr.join(',')\n    }\n\n    // 广度优先遍历\n    this.toStringBreadthFirst = function () {\n      const eleArr = []\n      let current = this.first\n      if (!current) {\n        return ''\n      }\n      const linkedList = new LinkedList()\n      linkedList.addLast(current)\n      while (linkedList.size > 0) {\n        // 利用队列来进行节点的遍历，先进先出，先左后右\n        const linkedFirst = linkedList.removeFirst().ele\n        eleArr.push(linkedFirst.ele)\n        if (linkedFirst.lc) {\n          linkedList.addLast(linkedFirst.lc)\n        }\n        if (linkedFirst.rc) {\n          linkedList.addLast(linkedFirst.rc)\n        }\n      }\n      return eleArr.join(',')\n    }\n\n    // 获取二叉树的层数\n    this.getFloor = function () {\n      return this.floor\n    }\n  }\n  ")]),t._v(" "),r("h3",[t._v("方法如下")]),t._v(" "),t._m(0),t._v(" "),r("h3",[t._v("实例使用如下")]),t._v(" "),r("pre",[t._v("  const tree = new Tree()\n  tree.add('A')\n  tree.add('B')\n  tree.add('C')\n  tree.add('D')\n  console.log('-------------深度优先遍历结果-------------')\n  let str = tree.toStringDeepFirst() // A,B,D,C\n  console.log(str)\n  console.log('-------------广度优先遍历结果-------------')\n  str = tree.toStringBreadthFirst() // A,B,C,D\n  console.log(str)\n  console.log('-------------删除最后一个节点-------------')\n  const last = tree.removeLast()\n  console.log('--------------最后一个节点----------------')\n  console.log(last) // Node {ele: \"D\", lc: null, rc: null, father: Node}\n  console.log('-------------广度优先遍历结果-------------')\n  str = tree.toStringBreadthFirst()\n  console.log(str) // A,B,C\n  console.log('---------------添加一个节点---------------')\n  tree.add('D') \n  str = tree.toStringBreadthFirst()\n  console.log(str) // A,B,C,D\n  console.log('--------------当前二叉树的层数------------')\n  console.log(tree.getFloor()) // 3\n  ")])])}]}},232:function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=r(216);n.default={mounted:function(){var t=new e.a;t.add("A"),t.add("B"),t.add("C"),t.add("D"),console.log("-------------深度优先遍历结果-------------");var n=t.toStringDeepFirst();console.log(n),console.log("-------------广度优先遍历结果-------------"),n=t.toStringBreadthFirst(),console.log(n),console.log("-------------删除最后一个节点-------------");var r=t.removeLast();console.log("--------------最后一个节点----------------"),console.log(r),console.log("-------------广度优先遍历结果-------------"),n=t.toStringBreadthFirst(),console.log(n),console.log("---------------添加一个节点---------------"),t.add("D"),n=t.toStringBreadthFirst(),console.log(n),console.log("--------------当前二叉树的层数------------"),console.log(t.getFloor())}}}});
//# sourceMappingURL=3.ff8d39a1e9f230f35772.js.map