{"version":3,"sources":["webpack:///static/js/3.ff8d39a1e9f230f35772.js","webpack:///./src/components/index/datastrcture/Tree.vue","webpack:///./src/assets/js/CommonUtil.js","webpack:///./src/components/index/datastrcture/Tree.vue?939e","webpack:///Tree.vue"],"names":["webpackJsonp","177","module","exports","__webpack_require__","Component","216","__webpack_exports__","d","LinkedList","Tree","Node","ele","this","next","prev","first","last","size","addFirst","node","addLast","removeFirst","removeFirstWithoutBack","removeLast","removeLastWithoutBack","removeIndex","index","count","currentNode","removeIndexWithoutBack","toString","arr","push","join","lc","rc","father","floor","add","current","toStringDeepFirst","eleArr","toStringBreadthFirst","linkedList","linkedFirst","getFloor","218","render","_vm","_h","$createElement","_self","_c","_m","staticRenderFns","_v","232","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0__assets_js_CommonUtil__","mounted","tree","console","log","str"],"mappings":"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","file":"static/js/3.ff8d39a1e9f230f35772.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 177:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(232),\n  /* template */\n  __webpack_require__(218),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 216:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return LinkedList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Tree; });\n// 有序链表\nvar LinkedList = function LinkedList() {\n  this.first = null;\n  this.last = null;\n  this.size = 0;\n\n  function Node(ele) {\n    this.next = null;\n    this.prev = null;\n    this.ele = ele;\n  }\n\n  // 向链表前面添加一个元素\n  this.addFirst = function (ele) {\n    var node = new Node(ele);\n    node.next = this.first;\n    if (this.size > 0) {\n      this.first.prev = node;\n    }\n    this.first = node;\n    if (this.size === 0) {\n      this.last = this.first;\n    } else {}\n    this.size++;\n  };\n\n  // 向链表后面添加一个元素\n  this.addLast = function (ele) {\n    var node = new Node(ele);\n    node.prev = this.last;\n    if (this.size > 0) {\n      this.last.next = node;\n    }\n    this.last = node;\n    if (this.size === 0) {\n      this.first = this.last;\n    }\n    this.size++;\n  };\n\n  // 删除第一个元素并返回第一个元素\n  this.removeFirst = function () {\n    if (this.size === 0) {\n      return null;\n    }\n    var first = this.first;\n    this.first = this.first.next;\n    if (this.first) {\n      this.first.prev = null;\n    } else {\n      this.last = null;\n    }\n    this.size--;\n    return first;\n  };\n  // 删除第一个元素，不返回元素\n  this.removeFirstWithoutBack = function () {\n    var first = this.removeFirst();\n    first = null;\n    return first;\n  };\n\n  // 删除最后一个元素并且返回最后一个元素\n  this.removeLast = function () {\n    if (this.size === 0) {\n      return null;\n    }\n    var last = this.last;\n    this.last = this.last.prev;\n    if (this.last) {\n      this.last.next = null;\n    } else {\n      this.first = null;\n    }\n    this.size--;\n    return last;\n  };\n  // 删除最后一个元素，不返回元素\n  this.removeLastWithoutBack = function () {\n    var last = this.removeLast();\n    last = null;\n    return last;\n  };\n\n  // 删除指定索引的元素并且返回指定元素\n  this.removeIndex = function (index) {\n    if (index >= this.size || index <= 0) {\n      return null;\n    }\n    switch (index) {\n      case 1:\n        return this.removeFirst();\n      case this.size - 1:\n        return this.removeLast();\n      default:\n        var count = 1;\n        var currentNode = this.first;\n        while (count !== index) {\n          count++;\n          currentNode = currentNode.next;\n          if (count === index) {\n            currentNode.prev.next = currentNode.next;\n            currentNode.next.prev = currentNode.prev;\n            return currentNode;\n          }\n        }\n        break;\n    }\n  };\n  // 删除指定索引的元素，不返回元素\n  this.removeIndexWithoutBack = function (index) {\n    var indexNode = this.removeIndex(index);\n    indexNode = null;\n    return indexNode;\n  };\n\n  this.toString = function () {\n    var currentNode = this.first;\n    var arr = [];\n    while (currentNode) {\n      arr.push(currentNode.ele);\n      currentNode = currentNode.next;\n    }\n    return arr.join(',');\n  };\n};\n\n// 标准二叉树\nvar Tree = function Tree() {\n  this.first = null;\n  this.last = null;\n  this.floor = 0;\n\n  function Node(ele) {\n    this.ele = ele;\n    this.lc = null;\n    this.rc = null;\n    this.father = null;\n  }\n\n  // 往二叉树加入一个节点\n  this.add = function (ele) {\n    var node = new Node(ele);\n    if (this.floor === 0) {\n      // 一个元素都没有\n      this.first = node;\n      this.floor++;\n    } else if (this.floor === 1) {\n      // 只有一个元素\n      this.last.lc = node;\n      node.father = this.last;\n      this.floor++;\n    } else {\n      var current = this.last;\n      while (current) {\n        // 当前节点是父节点的左节点\n        if (current.father.lc === current) {\n          if (current.father.rc) {\n            // 父节点有右节点\n            current = current.father.rc;\n            while (current.lc) {\n              current = current.lc;\n            }\n            current.lc = node;\n            node.father = current;\n            break;\n          } else {\n            // 添加一个兄弟节点\n            current.father.rc = node;\n            node.father = current.father;\n            break;\n          }\n          // 当前节点是父节点的右节点\n        } else {\n          if (current.father === this.first) {\n            current = this.first;\n            while (current.lc) {\n              current = current.lc;\n            }\n            current.lc = node;\n            node.father = current;\n            this.floor++;\n            break;\n          }\n          current = current.father;\n        }\n      }\n    }\n    this.last = node;\n  };\n\n  // 删除二叉树的最后一个节点, 且返回节点\n  this.removeLast = function () {\n    var last = this.last;\n    var current = this.last;\n    if (this.floor === 0) {\n      return null;\n    }\n    if (this.floor === 1) {\n      this.first = null;\n      this.last = null;\n      this.floor = 0;\n      return last;\n    }\n    if (current === current.father.lc) {\n      while (current.father) {\n        // 左节点\n        if (current === current.father.lc) {\n          current = current.father;\n          continue;\n        }\n        if (current === current.father.rc) {\n          current = current.father.lc;\n          while (current.rc) {\n            current = current.rc;\n          }\n          this.last = current;\n          // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\n          last.father.lc = null;\n          return last;\n        }\n      }\n      while (current.rc) {\n        current = current.rc;\n      }\n      last.father.lc = null;\n      this.last = current;\n      this.floor--;\n      return last;\n    }\n    if (current === current.father.rc) {\n      current.father.rc = null;\n      this.last = current.father.lc;\n      return last;\n    }\n  };\n  // 删除二叉树的最后一个节点, 不返回节点\n  this.removeLastWithoutBack = function () {\n    var last = this.removeLast();\n    last = null;\n    return last;\n  };\n\n  // 深度优先遍历\n  this.toStringDeepFirst = function () {\n    function next(current) {\n      var ele = current.ele;\n      eleArr.push(ele);\n      // 深度优先，所以只要有左节点就继续往下找\n      if (current.lc) {\n        next(current.lc);\n        return;\n      }\n      // 没有左节点，需要看是否有父节点，父节点是否有右节点\n      // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\n      // 关键：父节点的右节点不能是当前节点，否则会死循环\n      while (current && current.father) {\n        if (current.father.rc && current.father.rc !== current) {\n          next(current.father.rc);\n          return;\n        }\n        current = current.father;\n      }\n    }\n\n    // function next (current) {\n    //   const ele = current.ele\n    //   eleArr.push(ele)\n    //   if (current.lc) {\n    //     next(current.lc)\n    //   }\n    //   if (current.rc) {\n    //     next(current.rc)\n    //   }\n    // }\n    var eleArr = [];\n    if (this.first) {\n      next(this.first);\n    }\n    return eleArr.join(',');\n  };\n\n  // 广度优先遍历\n  this.toStringBreadthFirst = function () {\n    var eleArr = [];\n    var current = this.first;\n    if (!current) {\n      return '';\n    }\n    var linkedList = new LinkedList();\n    linkedList.addLast(current);\n    while (linkedList.size > 0) {\n      // 利用队列来进行节点的遍历，先进先出，先左后右\n      var linkedFirst = linkedList.removeFirst().ele;\n      eleArr.push(linkedFirst.ele);\n      if (linkedFirst.lc) {\n        linkedList.addLast(linkedFirst.lc);\n      }\n      if (linkedFirst.rc) {\n        linkedList.addLast(linkedFirst.rc);\n      }\n    }\n    return eleArr.join(',');\n  };\n\n  // 获取二叉树的层数\n  this.getFloor = function () {\n    return this.floor;\n  };\n};\n\n/***/ }),\n\n/***/ 218:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(1)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('pre', [_vm._v(\"    // 向二叉树加入一个数据\\n    \"), _c('span', [_vm._v(\"add(data)\")]), _vm._v(\";\\n\\n    // 移除最后一个数据(且返回最后一个数据)\\n    \"), _c('span', [_vm._v(\"removeLast()\")]), _vm._v(\";\\n\\n    // 移除最后一个数据(\"), _c('span', [_vm._v(\"不返回\")]), _vm._v(\"最后一个数据)\\n    \"), _c('span', [_vm._v(\"removeLastWithoutBack()\")]), _vm._v(\";\\n    \\n    // 深度优先遍历二叉树\\n    \"), _c('span', [_vm._v(\"toStringDeepFirst()\")]), _vm._v(\";\\n\\n    // 广度优先遍历二叉树\\n    \"), _c('span', [_vm._v(\"toStringBreadthFirst()\")]), _vm._v(\";\\n\\n    // 获取二叉树的层数\\n    \"), _c('span', [_vm._v(\"getFloor()\")]), _vm._v(\";\\n  \")])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h2', [_vm._v(\"js实现标准二叉树存储方式\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"构造函数如下\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"  function Tree () {\\n    this.first = null\\n    this.last = null\\n    this.floor = 0\\n\\n    function Node (ele) {\\n      this.ele = ele\\n      this.lc = null\\n      this.rc = null\\n      this.father = null\\n    }\\n\\n    // 往二叉树加入一个节点\\n    this.add = function (ele) {\\n      const node = new Node(ele)\\n      if (this.floor === 0) { // 一个元素都没有\\n        this.first = node\\n        this.floor++\\n      } else if (this.floor === 1) { // 只有一个元素\\n        this.last.lc = node\\n        node.father = this.last\\n        this.floor++\\n      } else {\\n        let current = this.last\\n        while (current) {\\n          // 当前节点是父节点的左节点\\n          if (current.father.lc === current) {\\n            if (current.father.rc) {\\n              // 父节点有右节点\\n              current = current.father.rc\\n              while (current.lc) {\\n                current = current.lc\\n              }\\n              current.lc = node\\n              node.father = current\\n              break\\n            } else {\\n              // 添加一个兄弟节点\\n              current.father.rc = node\\n              node.father = current.father\\n              break\\n            }\\n          // 当前节点是父节点的右节点\\n          } else {\\n            if (current.father === this.first) {\\n              current = this.first\\n              while (current.lc) {\\n                current = current.lc\\n              }\\n              current.lc = node\\n              node.father = current\\n              this.floor++\\n              break\\n            }\\n            current = current.father\\n          }\\n        }\\n      }\\n      this.last = node\\n    }\\n\\n    // 删除二叉树的最后一个节点, 且返回节点\\n    this.removeLast = function () {\\n      const last = this.last\\n      let current = this.last\\n      if (this.floor === 0) {\\n        return null\\n      }\\n      if (this.floor === 1) {\\n        this.first = null\\n        this.last = null\\n        this.floor = 0\\n        return last\\n      }\\n      if (current === current.father.lc) {\\n        while (current.father) {\\n          // 左节点\\n          if (current === current.father.lc) {\\n            current = current.father\\n            continue\\n          }\\n          if (current === current.father.rc) {\\n            current = current.father.lc\\n            while (current.rc) {\\n              current = current.rc\\n            }\\n            this.last = current\\n            // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\\n            last.father.lc = null\\n            return last\\n          }\\n        }\\n        while (current.rc) {\\n          current = current.rc\\n        }\\n        last.father.lc = null\\n        this.last = current\\n        this.floor--\\n        return last\\n      }\\n      if (current === current.father.rc) {\\n        current.father.rc = null\\n        this.last = current.father.lc\\n        return last\\n      }\\n    }\\n    // 删除二叉树的最后一个节点, 不返回节点\\n    this.removeLastWithoutBack = function () {\\n      let last = this.removeLast()\\n      last = null\\n      return last\\n    }\\n\\n    // 深度优先遍历（先序）\\n    this.toStringDeepFirst = function () {\\n      function next (current) {\\n        const ele = current.ele\\n        eleArr.push(ele)\\n        // 深度优先，所以只要有左节点就继续往下找\\n        if (current.lc) {\\n          next(current.lc)\\n          return\\n        }\\n        // 没有左节点，需要看是否有父节点，父节点是否有右节点\\n        // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\\n        // 关键：父节点的右节点不能是当前节点，否则会死循环\\n        while (current && current.father) {\\n          if (current.father.rc && current.father.rc !== current) {\\n            next(current.father.rc)\\n            return\\n          }\\n          current = current.father\\n        }\\n      }\\n\\n      // 深度优先另一种实现方式\\n      // function next (current) {\\n      //   const ele = current.ele\\n      //   eleArr.push(ele)\\n      //   if (current.lc) {\\n      //     next(current.lc)\\n      //   }\\n      //   if (current.rc) {\\n      //     next(current.rc)\\n      //   }\\n      // }\\n      const eleArr = []\\n      if (this.first) {\\n        next(this.first)\\n      }\\n      return eleArr.join(',')\\n    }\\n\\n    // 广度优先遍历\\n    this.toStringBreadthFirst = function () {\\n      const eleArr = []\\n      let current = this.first\\n      if (!current) {\\n        return ''\\n      }\\n      const linkedList = new LinkedList()\\n      linkedList.addLast(current)\\n      while (linkedList.size > 0) {\\n        // 利用队列来进行节点的遍历，先进先出，先左后右\\n        const linkedFirst = linkedList.removeFirst().ele\\n        eleArr.push(linkedFirst.ele)\\n        if (linkedFirst.lc) {\\n          linkedList.addLast(linkedFirst.lc)\\n        }\\n        if (linkedFirst.rc) {\\n          linkedList.addLast(linkedFirst.rc)\\n        }\\n      }\\n      return eleArr.join(',')\\n    }\\n\\n    // 获取二叉树的层数\\n    this.getFloor = function () {\\n      return this.floor\\n    }\\n  }\\n  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"方法如下\")]), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('h3', [_vm._v(\"实例使用如下\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"  const tree = new Tree()\\n  tree.add('A')\\n  tree.add('B')\\n  tree.add('C')\\n  tree.add('D')\\n  console.log('-------------深度优先遍历结果-------------')\\n  let str = tree.toStringDeepFirst() // A,B,D,C\\n  console.log(str)\\n  console.log('-------------广度优先遍历结果-------------')\\n  str = tree.toStringBreadthFirst() // A,B,C,D\\n  console.log(str)\\n  console.log('-------------删除最后一个节点-------------')\\n  const last = tree.removeLast()\\n  console.log('--------------最后一个节点----------------')\\n  console.log(last) // Node {ele: \\\"D\\\", lc: null, rc: null, father: Node}\\n  console.log('-------------广度优先遍历结果-------------')\\n  str = tree.toStringBreadthFirst()\\n  console.log(str) // A,B,C\\n  console.log('---------------添加一个节点---------------')\\n  tree.add('D') \\n  str = tree.toStringBreadthFirst()\\n  console.log(str) // A,B,C,D\\n  console.log('--------------当前二叉树的层数------------')\\n  console.log(tree.getFloor()) // 3\\n  \")])])\n}]}\n\n/***/ }),\n\n/***/ 232:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assets_js_CommonUtil__ = __webpack_require__(216);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  mounted: function mounted() {\n    var tree = new __WEBPACK_IMPORTED_MODULE_0__assets_js_CommonUtil__[\"a\" /* Tree */]();\n    tree.add('A');\n    tree.add('B');\n    tree.add('C');\n    tree.add('D');\n    console.log('-------------深度优先遍历结果-------------');\n    var str = tree.toStringDeepFirst();\n    console.log(str);\n    console.log('-------------广度优先遍历结果-------------');\n    str = tree.toStringBreadthFirst();\n    console.log(str);\n    console.log('-------------删除最后一个节点-------------');\n    var last = tree.removeLast();\n    console.log('--------------最后一个节点----------------');\n    console.log(last);\n    console.log('-------------广度优先遍历结果-------------');\n    str = tree.toStringBreadthFirst();\n    console.log(str);\n    console.log('---------------添加一个节点---------------');\n    tree.add('D');\n    str = tree.toStringBreadthFirst();\n    console.log(str);\n    console.log('--------------当前二叉树的层数------------');\n    console.log(tree.getFloor());\n  }\n});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/3.ff8d39a1e9f230f35772.js","var Component = require(\"!../../../../node_modules/.12.2.2@vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../node_modules/.12.2.2@vue-loader/lib/selector?type=script&index=0!./Tree.vue\"),\n  /* template */\n  require(\"!!../../../../node_modules/.12.2.2@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-161077dd\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":\\\"src\\\",\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"}}!../../../../node_modules/.12.2.2@vue-loader/lib/selector?type=template&index=0!./Tree.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/index/datastrcture/Tree.vue\n// module id = 177\n// module chunks = 3","// 有序链表\r\nexport const LinkedList = function () {\r\n  this.first = null\r\n  this.last = null\r\n  this.size = 0\r\n\r\n  function Node (ele) {\r\n    this.next = null\r\n    this.prev = null\r\n    this.ele = ele\r\n  }\r\n\r\n  // 向链表前面添加一个元素\r\n  this.addFirst = function (ele) {\r\n    var node = new Node(ele)\r\n    node.next = this.first\r\n    if (this.size > 0) {\r\n      this.first.prev = node\r\n    }\r\n    this.first = node\r\n    if (this.size === 0) {\r\n      this.last = this.first\r\n    } else {\r\n\r\n    }\r\n    this.size++\r\n  }\r\n\r\n  // 向链表后面添加一个元素\r\n  this.addLast = function (ele) {\r\n    var node = new Node(ele)\r\n    node.prev = this.last\r\n    if (this.size > 0) {\r\n      this.last.next = node\r\n    }\r\n    this.last = node\r\n    if (this.size === 0) {\r\n      this.first = this.last\r\n    }\r\n    this.size++\r\n  }\r\n\r\n  // 删除第一个元素并返回第一个元素\r\n  this.removeFirst = function () {\r\n    if (this.size === 0) {\r\n      return null\r\n    }\r\n    const first = this.first\r\n    this.first = this.first.next\r\n    if (this.first) {\r\n      this.first.prev = null\r\n    } else {\r\n      this.last = null\r\n    }\r\n    this.size--\r\n    return first\r\n  }\r\n  // 删除第一个元素，不返回元素\r\n  this.removeFirstWithoutBack = function () {\r\n    let first = this.removeFirst()\r\n    first = null\r\n    return first\r\n  }\r\n\r\n  // 删除最后一个元素并且返回最后一个元素\r\n  this.removeLast = function () {\r\n    if (this.size === 0) {\r\n      return null\r\n    }\r\n    const last = this.last\r\n    this.last = this.last.prev\r\n    if (this.last) {\r\n      this.last.next = null\r\n    } else {\r\n      this.first = null\r\n    }\r\n    this.size--\r\n    return last\r\n  }\r\n  // 删除最后一个元素，不返回元素\r\n  this.removeLastWithoutBack = function () {\r\n    let last = this.removeLast()\r\n    last = null\r\n    return last\r\n  }\r\n\r\n  // 删除指定索引的元素并且返回指定元素\r\n  this.removeIndex = function (index) {\r\n    if (index >= this.size || index <= 0) {\r\n      return null\r\n    }\r\n    switch (index) {\r\n      case 1:\r\n        return this.removeFirst()\r\n      case (this.size - 1):\r\n        return this.removeLast()\r\n      default:\r\n        let count = 1\r\n        let currentNode = this.first\r\n        while (count !== index) {\r\n          count++\r\n          currentNode = currentNode.next\r\n          if (count === index) {\r\n            currentNode.prev.next = currentNode.next\r\n            currentNode.next.prev = currentNode.prev\r\n            return currentNode\r\n          }\r\n        }\r\n        break\r\n    }\r\n  }\r\n  // 删除指定索引的元素，不返回元素\r\n  this.removeIndexWithoutBack = function (index) {\r\n    let indexNode = this.removeIndex(index)\r\n    indexNode = null\r\n    return indexNode\r\n  }\r\n\r\n  this.toString = function () {\r\n    var currentNode = this.first\r\n    var arr = []\r\n    while (currentNode) {\r\n      arr.push(currentNode.ele)\r\n      currentNode = currentNode.next\r\n    }\r\n    return arr.join(',')\r\n  }\r\n}\r\n\r\n// 标准二叉树\r\nexport const Tree = function () {\r\n  this.first = null\r\n  this.last = null\r\n  this.floor = 0\r\n\r\n  function Node (ele) {\r\n    this.ele = ele\r\n    this.lc = null\r\n    this.rc = null\r\n    this.father = null\r\n  }\r\n\r\n  // 往二叉树加入一个节点\r\n  this.add = function (ele) {\r\n    const node = new Node(ele)\r\n    if (this.floor === 0) { // 一个元素都没有\r\n      this.first = node\r\n      this.floor++\r\n    } else if (this.floor === 1) { // 只有一个元素\r\n      this.last.lc = node\r\n      node.father = this.last\r\n      this.floor++\r\n    } else {\r\n      let current = this.last\r\n      while (current) {\r\n        // 当前节点是父节点的左节点\r\n        if (current.father.lc === current) {\r\n          if (current.father.rc) {\r\n            // 父节点有右节点\r\n            current = current.father.rc\r\n            while (current.lc) {\r\n              current = current.lc\r\n            }\r\n            current.lc = node\r\n            node.father = current\r\n            break\r\n          } else {\r\n            // 添加一个兄弟节点\r\n            current.father.rc = node\r\n            node.father = current.father\r\n            break\r\n          }\r\n        // 当前节点是父节点的右节点\r\n        } else {\r\n          if (current.father === this.first) {\r\n            current = this.first\r\n            while (current.lc) {\r\n              current = current.lc\r\n            }\r\n            current.lc = node\r\n            node.father = current\r\n            this.floor++\r\n            break\r\n          }\r\n          current = current.father\r\n        }\r\n      }\r\n    }\r\n    this.last = node\r\n  }\r\n\r\n  // 删除二叉树的最后一个节点, 且返回节点\r\n  this.removeLast = function () {\r\n    const last = this.last\r\n    let current = this.last\r\n    if (this.floor === 0) {\r\n      return null\r\n    }\r\n    if (this.floor === 1) {\r\n      this.first = null\r\n      this.last = null\r\n      this.floor = 0\r\n      return last\r\n    }\r\n    if (current === current.father.lc) {\r\n      while (current.father) {\r\n        // 左节点\r\n        if (current === current.father.lc) {\r\n          current = current.father\r\n          continue\r\n        }\r\n        if (current === current.father.rc) {\r\n          current = current.father.lc\r\n          while (current.rc) {\r\n            current = current.rc\r\n          }\r\n          this.last = current\r\n          // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\r\n          last.father.lc = null\r\n          return last\r\n        }\r\n      }\r\n      while (current.rc) {\r\n        current = current.rc\r\n      }\r\n      last.father.lc = null\r\n      this.last = current\r\n      this.floor--\r\n      return last\r\n    }\r\n    if (current === current.father.rc) {\r\n      current.father.rc = null\r\n      this.last = current.father.lc\r\n      return last\r\n    }\r\n  }\r\n  // 删除二叉树的最后一个节点, 不返回节点\r\n  this.removeLastWithoutBack = function () {\r\n    let last = this.removeLast()\r\n    last = null\r\n    return last\r\n  }\r\n\r\n  // 深度优先遍历\r\n  this.toStringDeepFirst = function () {\r\n    function next (current) {\r\n      const ele = current.ele\r\n      eleArr.push(ele)\r\n      // 深度优先，所以只要有左节点就继续往下找\r\n      if (current.lc) {\r\n        next(current.lc)\r\n        return\r\n      }\r\n      // 没有左节点，需要看是否有父节点，父节点是否有右节点\r\n      // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\r\n      // 关键：父节点的右节点不能是当前节点，否则会死循环\r\n      while (current && current.father) {\r\n        if (current.father.rc && current.father.rc !== current) {\r\n          next(current.father.rc)\r\n          return\r\n        }\r\n        current = current.father\r\n      }\r\n    }\r\n\r\n    // function next (current) {\r\n    //   const ele = current.ele\r\n    //   eleArr.push(ele)\r\n    //   if (current.lc) {\r\n    //     next(current.lc)\r\n    //   }\r\n    //   if (current.rc) {\r\n    //     next(current.rc)\r\n    //   }\r\n    // }\r\n    const eleArr = []\r\n    if (this.first) {\r\n      next(this.first)\r\n    }\r\n    return eleArr.join(',')\r\n  }\r\n\r\n  // 广度优先遍历\r\n  this.toStringBreadthFirst = function () {\r\n    const eleArr = []\r\n    let current = this.first\r\n    if (!current) {\r\n      return ''\r\n    }\r\n    const linkedList = new LinkedList()\r\n    linkedList.addLast(current)\r\n    while (linkedList.size > 0) {\r\n      // 利用队列来进行节点的遍历，先进先出，先左后右\r\n      const linkedFirst = linkedList.removeFirst().ele\r\n      eleArr.push(linkedFirst.ele)\r\n      if (linkedFirst.lc) {\r\n        linkedList.addLast(linkedFirst.lc)\r\n      }\r\n      if (linkedFirst.rc) {\r\n        linkedList.addLast(linkedFirst.rc)\r\n      }\r\n    }\r\n    return eleArr.join(',')\r\n  }\r\n\r\n  // 获取二叉树的层数\r\n  this.getFloor = function () {\r\n    return this.floor\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/assets/js/CommonUtil.js","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _vm._m(1)\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('pre', [_vm._v(\"    // 向二叉树加入一个数据\\n    \"), _c('span', [_vm._v(\"add(data)\")]), _vm._v(\";\\n\\n    // 移除最后一个数据(且返回最后一个数据)\\n    \"), _c('span', [_vm._v(\"removeLast()\")]), _vm._v(\";\\n\\n    // 移除最后一个数据(\"), _c('span', [_vm._v(\"不返回\")]), _vm._v(\"最后一个数据)\\n    \"), _c('span', [_vm._v(\"removeLastWithoutBack()\")]), _vm._v(\";\\n    \\n    // 深度优先遍历二叉树\\n    \"), _c('span', [_vm._v(\"toStringDeepFirst()\")]), _vm._v(\";\\n\\n    // 广度优先遍历二叉树\\n    \"), _c('span', [_vm._v(\"toStringBreadthFirst()\")]), _vm._v(\";\\n\\n    // 获取二叉树的层数\\n    \"), _c('span', [_vm._v(\"getFloor()\")]), _vm._v(\";\\n  \")])\n},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h2', [_vm._v(\"js实现标准二叉树存储方式\")]), _vm._v(\" \"), _c('h3', [_vm._v(\"构造函数如下\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"  function Tree () {\\n    this.first = null\\n    this.last = null\\n    this.floor = 0\\n\\n    function Node (ele) {\\n      this.ele = ele\\n      this.lc = null\\n      this.rc = null\\n      this.father = null\\n    }\\n\\n    // 往二叉树加入一个节点\\n    this.add = function (ele) {\\n      const node = new Node(ele)\\n      if (this.floor === 0) { // 一个元素都没有\\n        this.first = node\\n        this.floor++\\n      } else if (this.floor === 1) { // 只有一个元素\\n        this.last.lc = node\\n        node.father = this.last\\n        this.floor++\\n      } else {\\n        let current = this.last\\n        while (current) {\\n          // 当前节点是父节点的左节点\\n          if (current.father.lc === current) {\\n            if (current.father.rc) {\\n              // 父节点有右节点\\n              current = current.father.rc\\n              while (current.lc) {\\n                current = current.lc\\n              }\\n              current.lc = node\\n              node.father = current\\n              break\\n            } else {\\n              // 添加一个兄弟节点\\n              current.father.rc = node\\n              node.father = current.father\\n              break\\n            }\\n          // 当前节点是父节点的右节点\\n          } else {\\n            if (current.father === this.first) {\\n              current = this.first\\n              while (current.lc) {\\n                current = current.lc\\n              }\\n              current.lc = node\\n              node.father = current\\n              this.floor++\\n              break\\n            }\\n            current = current.father\\n          }\\n        }\\n      }\\n      this.last = node\\n    }\\n\\n    // 删除二叉树的最后一个节点, 且返回节点\\n    this.removeLast = function () {\\n      const last = this.last\\n      let current = this.last\\n      if (this.floor === 0) {\\n        return null\\n      }\\n      if (this.floor === 1) {\\n        this.first = null\\n        this.last = null\\n        this.floor = 0\\n        return last\\n      }\\n      if (current === current.father.lc) {\\n        while (current.father) {\\n          // 左节点\\n          if (current === current.father.lc) {\\n            current = current.father\\n            continue\\n          }\\n          if (current === current.father.rc) {\\n            current = current.father.lc\\n            while (current.rc) {\\n              current = current.rc\\n            }\\n            this.last = current\\n            // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\\n            last.father.lc = null\\n            return last\\n          }\\n        }\\n        while (current.rc) {\\n          current = current.rc\\n        }\\n        last.father.lc = null\\n        this.last = current\\n        this.floor--\\n        return last\\n      }\\n      if (current === current.father.rc) {\\n        current.father.rc = null\\n        this.last = current.father.lc\\n        return last\\n      }\\n    }\\n    // 删除二叉树的最后一个节点, 不返回节点\\n    this.removeLastWithoutBack = function () {\\n      let last = this.removeLast()\\n      last = null\\n      return last\\n    }\\n\\n    // 深度优先遍历（先序）\\n    this.toStringDeepFirst = function () {\\n      function next (current) {\\n        const ele = current.ele\\n        eleArr.push(ele)\\n        // 深度优先，所以只要有左节点就继续往下找\\n        if (current.lc) {\\n          next(current.lc)\\n          return\\n        }\\n        // 没有左节点，需要看是否有父节点，父节点是否有右节点\\n        // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\\n        // 关键：父节点的右节点不能是当前节点，否则会死循环\\n        while (current && current.father) {\\n          if (current.father.rc && current.father.rc !== current) {\\n            next(current.father.rc)\\n            return\\n          }\\n          current = current.father\\n        }\\n      }\\n\\n      // 深度优先另一种实现方式\\n      // function next (current) {\\n      //   const ele = current.ele\\n      //   eleArr.push(ele)\\n      //   if (current.lc) {\\n      //     next(current.lc)\\n      //   }\\n      //   if (current.rc) {\\n      //     next(current.rc)\\n      //   }\\n      // }\\n      const eleArr = []\\n      if (this.first) {\\n        next(this.first)\\n      }\\n      return eleArr.join(',')\\n    }\\n\\n    // 广度优先遍历\\n    this.toStringBreadthFirst = function () {\\n      const eleArr = []\\n      let current = this.first\\n      if (!current) {\\n        return ''\\n      }\\n      const linkedList = new LinkedList()\\n      linkedList.addLast(current)\\n      while (linkedList.size > 0) {\\n        // 利用队列来进行节点的遍历，先进先出，先左后右\\n        const linkedFirst = linkedList.removeFirst().ele\\n        eleArr.push(linkedFirst.ele)\\n        if (linkedFirst.lc) {\\n          linkedList.addLast(linkedFirst.lc)\\n        }\\n        if (linkedFirst.rc) {\\n          linkedList.addLast(linkedFirst.rc)\\n        }\\n      }\\n      return eleArr.join(',')\\n    }\\n\\n    // 获取二叉树的层数\\n    this.getFloor = function () {\\n      return this.floor\\n    }\\n  }\\n  \")]), _vm._v(\" \"), _c('h3', [_vm._v(\"方法如下\")]), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('h3', [_vm._v(\"实例使用如下\")]), _vm._v(\" \"), _c('pre', [_vm._v(\"  const tree = new Tree()\\n  tree.add('A')\\n  tree.add('B')\\n  tree.add('C')\\n  tree.add('D')\\n  console.log('-------------深度优先遍历结果-------------')\\n  let str = tree.toStringDeepFirst() // A,B,D,C\\n  console.log(str)\\n  console.log('-------------广度优先遍历结果-------------')\\n  str = tree.toStringBreadthFirst() // A,B,C,D\\n  console.log(str)\\n  console.log('-------------删除最后一个节点-------------')\\n  const last = tree.removeLast()\\n  console.log('--------------最后一个节点----------------')\\n  console.log(last) // Node {ele: \\\"D\\\", lc: null, rc: null, father: Node}\\n  console.log('-------------广度优先遍历结果-------------')\\n  str = tree.toStringBreadthFirst()\\n  console.log(str) // A,B,C\\n  console.log('---------------添加一个节点---------------')\\n  tree.add('D') \\n  str = tree.toStringBreadthFirst()\\n  console.log(str) // A,B,C,D\\n  console.log('--------------当前二叉树的层数------------')\\n  console.log(tree.getFloor()) // 3\\n  \")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.12.2.2@vue-loader/lib/template-compiler?{\"id\":\"data-v-161077dd\",\"hasScoped\":false,\"transformToRequire\":{\"video\":\"src\",\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./~/.12.2.2@vue-loader/lib/selector.js?type=template&index=0!./src/components/index/datastrcture/Tree.vue\n// module id = 218\n// module chunks = 3","<template>\r\n  <div v-once>\r\n    <h2>js实现标准二叉树存储方式</h2>\r\n    <h3>构造函数如下</h3>\r\n    <pre>\r\n    function Tree () {\r\n      this.first = null\r\n      this.last = null\r\n      this.floor = 0\r\n\r\n      function Node (ele) {\r\n        this.ele = ele\r\n        this.lc = null\r\n        this.rc = null\r\n        this.father = null\r\n      }\r\n\r\n      // 往二叉树加入一个节点\r\n      this.add = function (ele) {\r\n        const node = new Node(ele)\r\n        if (this.floor === 0) { // 一个元素都没有\r\n          this.first = node\r\n          this.floor++\r\n        } else if (this.floor === 1) { // 只有一个元素\r\n          this.last.lc = node\r\n          node.father = this.last\r\n          this.floor++\r\n        } else {\r\n          let current = this.last\r\n          while (current) {\r\n            // 当前节点是父节点的左节点\r\n            if (current.father.lc === current) {\r\n              if (current.father.rc) {\r\n                // 父节点有右节点\r\n                current = current.father.rc\r\n                while (current.lc) {\r\n                  current = current.lc\r\n                }\r\n                current.lc = node\r\n                node.father = current\r\n                break\r\n              } else {\r\n                // 添加一个兄弟节点\r\n                current.father.rc = node\r\n                node.father = current.father\r\n                break\r\n              }\r\n            // 当前节点是父节点的右节点\r\n            } else {\r\n              if (current.father === this.first) {\r\n                current = this.first\r\n                while (current.lc) {\r\n                  current = current.lc\r\n                }\r\n                current.lc = node\r\n                node.father = current\r\n                this.floor++\r\n                break\r\n              }\r\n              current = current.father\r\n            }\r\n          }\r\n        }\r\n        this.last = node\r\n      }\r\n\r\n      // 删除二叉树的最后一个节点, 且返回节点\r\n      this.removeLast = function () {\r\n        const last = this.last\r\n        let current = this.last\r\n        if (this.floor === 0) {\r\n          return null\r\n        }\r\n        if (this.floor === 1) {\r\n          this.first = null\r\n          this.last = null\r\n          this.floor = 0\r\n          return last\r\n        }\r\n        if (current === current.father.lc) {\r\n          while (current.father) {\r\n            // 左节点\r\n            if (current === current.father.lc) {\r\n              current = current.father\r\n              continue\r\n            }\r\n            if (current === current.father.rc) {\r\n              current = current.father.lc\r\n              while (current.rc) {\r\n                current = current.rc\r\n              }\r\n              this.last = current\r\n              // 需要把删除之前的最后一个节点在父节点的子节点置为null,否则还可以遍历出来\r\n              last.father.lc = null\r\n              return last\r\n            }\r\n          }\r\n          while (current.rc) {\r\n            current = current.rc\r\n          }\r\n          last.father.lc = null\r\n          this.last = current\r\n          this.floor--\r\n          return last\r\n        }\r\n        if (current === current.father.rc) {\r\n          current.father.rc = null\r\n          this.last = current.father.lc\r\n          return last\r\n        }\r\n      }\r\n      // 删除二叉树的最后一个节点, 不返回节点\r\n      this.removeLastWithoutBack = function () {\r\n        let last = this.removeLast()\r\n        last = null\r\n        return last\r\n      }\r\n\r\n      // 深度优先遍历（先序）\r\n      this.toStringDeepFirst = function () {\r\n        function next (current) {\r\n          const ele = current.ele\r\n          eleArr.push(ele)\r\n          // 深度优先，所以只要有左节点就继续往下找\r\n          if (current.lc) {\r\n            next(current.lc)\r\n            return\r\n          }\r\n          // 没有左节点，需要看是否有父节点，父节点是否有右节点\r\n          // (不用查看是否有右节点，因为是二叉树，没有左节点一定没有右节点)\r\n          // 关键：父节点的右节点不能是当前节点，否则会死循环\r\n          while (current && current.father) {\r\n            if (current.father.rc && current.father.rc !== current) {\r\n              next(current.father.rc)\r\n              return\r\n            }\r\n            current = current.father\r\n          }\r\n        }\r\n\r\n        // 深度优先另一种实现方式\r\n        // function next (current) {\r\n        //   const ele = current.ele\r\n        //   eleArr.push(ele)\r\n        //   if (current.lc) {\r\n        //     next(current.lc)\r\n        //   }\r\n        //   if (current.rc) {\r\n        //     next(current.rc)\r\n        //   }\r\n        // }\r\n        const eleArr = []\r\n        if (this.first) {\r\n          next(this.first)\r\n        }\r\n        return eleArr.join(',')\r\n      }\r\n\r\n      // 广度优先遍历\r\n      this.toStringBreadthFirst = function () {\r\n        const eleArr = []\r\n        let current = this.first\r\n        if (!current) {\r\n          return ''\r\n        }\r\n        const linkedList = new LinkedList()\r\n        linkedList.addLast(current)\r\n        while (linkedList.size > 0) {\r\n          // 利用队列来进行节点的遍历，先进先出，先左后右\r\n          const linkedFirst = linkedList.removeFirst().ele\r\n          eleArr.push(linkedFirst.ele)\r\n          if (linkedFirst.lc) {\r\n            linkedList.addLast(linkedFirst.lc)\r\n          }\r\n          if (linkedFirst.rc) {\r\n            linkedList.addLast(linkedFirst.rc)\r\n          }\r\n        }\r\n        return eleArr.join(',')\r\n      }\r\n\r\n      // 获取二叉树的层数\r\n      this.getFloor = function () {\r\n        return this.floor\r\n      }\r\n    }\r\n    </pre>\r\n    <h3>方法如下</h3>\r\n    <pre>\r\n      // 向二叉树加入一个数据\r\n      <span>add(data)</span>;\r\n\r\n      // 移除最后一个数据(且返回最后一个数据)\r\n      <span>removeLast()</span>;\r\n\r\n      // 移除最后一个数据(<span>不返回</span>最后一个数据)\r\n      <span>removeLastWithoutBack()</span>;\r\n      \r\n      // 深度优先遍历二叉树\r\n      <span>toStringDeepFirst()</span>;\r\n\r\n      // 广度优先遍历二叉树\r\n      <span>toStringBreadthFirst()</span>;\r\n\r\n      // 获取二叉树的层数\r\n      <span>getFloor()</span>;\r\n    </pre>\r\n    <h3>实例使用如下</h3>\r\n    <pre>\r\n    const tree = new Tree()\r\n    tree.add('A')\r\n    tree.add('B')\r\n    tree.add('C')\r\n    tree.add('D')\r\n    console.log('-------------深度优先遍历结果-------------')\r\n    let str = tree.toStringDeepFirst() // A,B,D,C\r\n    console.log(str)\r\n    console.log('-------------广度优先遍历结果-------------')\r\n    str = tree.toStringBreadthFirst() // A,B,C,D\r\n    console.log(str)\r\n    console.log('-------------删除最后一个节点-------------')\r\n    const last = tree.removeLast()\r\n    console.log('--------------最后一个节点----------------')\r\n    console.log(last) // Node {ele: \"D\", lc: null, rc: null, father: Node}\r\n    console.log('-------------广度优先遍历结果-------------')\r\n    str = tree.toStringBreadthFirst()\r\n    console.log(str) // A,B,C\r\n    console.log('---------------添加一个节点---------------')\r\n    tree.add('D') \r\n    str = tree.toStringBreadthFirst()\r\n    console.log(str) // A,B,C,D\r\n    console.log('--------------当前二叉树的层数------------')\r\n    console.log(tree.getFloor()) // 3\r\n    </pre>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { Tree } from '@/assets/js/CommonUtil'\r\n\r\nexport default {\r\n  mounted () {\r\n    const tree = new Tree()\r\n    tree.add('A')\r\n    tree.add('B')\r\n    tree.add('C')\r\n    tree.add('D')\r\n    console.log('-------------深度优先遍历结果-------------')\r\n    let str = tree.toStringDeepFirst()\r\n    console.log(str)\r\n    console.log('-------------广度优先遍历结果-------------')\r\n    str = tree.toStringBreadthFirst()\r\n    console.log(str)\r\n    console.log('-------------删除最后一个节点-------------')\r\n    const last = tree.removeLast()\r\n    console.log('--------------最后一个节点----------------')\r\n    console.log(last)\r\n    console.log('-------------广度优先遍历结果-------------')\r\n    str = tree.toStringBreadthFirst()\r\n    console.log(str)\r\n    console.log('---------------添加一个节点---------------')\r\n    tree.add('D')\r\n    str = tree.toStringBreadthFirst()\r\n    console.log(str)\r\n    console.log('--------------当前二叉树的层数------------')\r\n    console.log(tree.getFloor())\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Tree.vue?46ce79eb"],"sourceRoot":""}